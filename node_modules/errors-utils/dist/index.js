export class StackError extends Error {
    /**
   * Casts an `Error` to a `StackError`, using the given `code`. Calling this function with an
   * instance of `StackError` will return the input unchanged.
   */ static from(error, code = 'SE0') {
        if (error instanceof StackError) {
            return error;
        }
        const se = new StackError(code, error.message);
        se.stack = error.stack;
        return se;
    }
    static fromJSON(json) {
        const error = new StackError(json.code, json.message);
        error.errorStack = (json.stack ?? []).reduceRight((stack, e)=>{
            const err = StackError.fromJSON(e);
            err.errorStack = stack;
            return [
                err,
                ...stack
            ];
        }, []);
        error.metadata = json.metadata ?? {};
        error.name = json.name ?? 'StackError';
        return error;
    }
    toErrorStack() {
        return [
            this,
            ...this.errorStack
        ];
    }
    /**
   * Serializes the error to JSON. By default the `errorStack` is included on a single level,
   * setting the `withStack` argument to `false` will serialize the error only, discarding the
   * stack.
   */ toJSON(withStack = true) {
        return {
            code: this.code,
            message: this.message,
            metadata: this.metadata,
            name: this.name,
            stack: withStack ? this.errorStack.map((e)=>e.toJSON(false)
            ) : []
        };
    }
    toString() {
        return `[${this.code}] ${this.message}`;
    }
    constructor(code, message, wrapError){
        super(message);
        this.metadata = {};
        this.name = 'StackError';
        Object.setPrototypeOf(this, StackError.prototype);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, StackError);
        }
        this.code = code;
        this.errorStack = wrapError ? StackError.from(wrapError).toErrorStack() : [];
    }
}
/**
 * Factory for an Error class extending `StackError` with a given `namespace` and optional
 * `metadata`.
 */ // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
export function createNamespaceError(namespace, metadata = {}) {
    return class NamespaceError extends StackError {
        constructor(code, message, wrapError){
            super(`${namespace}${code}`, message, wrapError);
            Object.setPrototypeOf(this, NamespaceError.prototype);
            if (Error.captureStackTrace) {
                Error.captureStackTrace(this, NamespaceError);
            }
            this.metadata = metadata;
        }
    };
}
/**
 * Asserts the given `condition` is true or throws an Error with the given `message`.
 */ export function assert(condition, message = 'Assertion failed') {
    if (!condition) {
        throw new Error(message);
    }
}
/**
 * Asserts the given `condition` is true or throws an Error using the given `ErrorClass` and
 * associated arguments.
 */ export function assertAs(condition, ErrorClass, ...args) {
    if (!condition) {
        // @ts-ignore args
        throw new ErrorClass(...args);
    }
}
