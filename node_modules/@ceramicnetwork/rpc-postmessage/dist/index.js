/**
 * ```sh
 * npm install @ceramicnetwork/rpc-postmessage
 * ```
 *
 * @module rpc-postmessage
 */ import { createHandlerOperator } from '@ceramicnetwork/rpc-transport';
import { createUnwrap, createUnwrapOperator, createWrap, createWrapObserver, createWrapper } from '@ceramicnetwork/transport-subject';
import { createMessageObservable, createPostMessageTransport } from '@ceramicnetwork/transport-postmessage';
import { RPCClient, createHandler } from 'rpc-utils';
import { pipe } from 'rxjs';
import { filter, first, map, mergeMap, tap } from 'rxjs/operators';
export function serve({ target , methods , ...options }) {
    const transport = createPostMessageTransport(target);
    return transport.pipe(map((event)=>event.data
    ), createHandlerOperator(null, methods, options), filter((res)=>res != null
    )).subscribe(transport);
}
export function createNamespaceRequestHandlerOperator(methods, namespace, options = {}) {
    const handleRequest = createHandler(methods, options);
    const unwrap = createUnwrap(namespace);
    return pipe(map((message)=>{
        try {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            const request = unwrap(message.data) // TS error: semantic error TS2339: Property 'data' does not exist on type 'Message'
            ;
            return request.method ? {
                type: 'request',
                message,
                request
            } : null;
        } catch (_error) {
            return null;
        }
    }), filter((payload)=>{
        return payload !== null;
    }), mergeMap(async (payload)=>{
        return {
            type: 'handled',
            message: payload.message,
            request: payload.request,
            response: await handleRequest(payload.message, payload.request)
        };
    }));
}
export function createNamespaceServer({ filter: messageFilter , methods , namespace , target , ...options }) {
    const wrap = createWrap(namespace);
    return createMessageObservable(target, messageFilter).pipe(createNamespaceRequestHandlerOperator(methods, namespace, options), tap((payload)=>{
        if (payload.response != null) {
            const source = payload.message.source ?? window;
            source.postMessage(wrap(payload.response), payload.message.origin || '*');
        }
    }));
}
export function createNamespaceSendRequest(transport, namespace, options) {
    const wrapper = createWrapper(namespace);
    const observer = createWrapObserver(transport, wrapper.wrap);
    const unwrap = createUnwrapOperator(wrapper.unwrap, options);
    return async function send(req) {
        return new Promise((resolve, reject)=>{
            const subscription = transport.pipe(map((message)=>message.data
            ), unwrap, first((res)=>res != null && res.id === req.id && ('error' in res || 'result' in res)
            )).subscribe({
                next: (res)=>{
                    resolve(res);
                    subscription.unsubscribe();
                },
                error: reject
            });
            observer.next(req);
        });
    };
}
export function createNamespaceClient(transport, namespace, options) {
    const send = createNamespaceSendRequest(transport, namespace, options);
    return new RPCClient({
        send
    });
}
