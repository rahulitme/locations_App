/**
 * ```sh
 * npm install @ceramicnetwork/transport-subject
 * ```
 *
 * @module transport-subject
 */ import { Subject, Subscription, pipe } from 'rxjs';
import { filter, map } from 'rxjs/operators';
export class TransportSubject extends Subject {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore MsgOut can be different from MsgIn
    next(message) {
        this._sink.next?.(message);
    }
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    error(err) {
        this._sink.error?.(err);
    }
    complete() {
        this._sink.complete?.();
    }
    _subscribe(observer) {
        return this._source.subscribe(observer) ?? Subscription.EMPTY;
    }
    constructor(source, sink){
        super();
        this._source = source;
        this._sink = sink;
    }
}
export function createWrap(namespace) {
    return function wrap(msg) {
        return {
            __tw: true,
            ns: namespace,
            msg
        };
    };
}
export function createUnwrap(namespace) {
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    return function unwrap(input) {
        /* eslint-disable @typescript-eslint/no-unsafe-member-access */ if (input.__tw !== true) {
            throw new Error('Input is not a wrapped message');
        }
        if (typeof input.ns !== 'string') {
            throw new Error(`Invalid namespace type for wrapped message: expected a string, got ${typeof input.ns}`);
        }
        if (input.ns !== namespace) {
            throw new Error(`Invalid namespace for wrapped message: expected ${namespace}, got ${input.ns}`);
        }
        return input.msg;
    /* eslint-enable @typescript-eslint/no-unsafe-member-access */ };
}
export function createWrapper(namespace) {
    return {
        wrap: createWrap(namespace),
        unwrap: createUnwrap(namespace)
    };
}
export function createUnwrapOperator(unwrap, options = {}) {
    if (options.throwWhenInvalid) {
        return pipe(map(unwrap));
    }
    const onInvalid = typeof options.onInvalidInput === 'function' ? options.onInvalidInput : function onInvalid(input, error) {
        console.warn('Invalid transport input', input, error);
    };
    return pipe(map((input)=>{
        try {
            return unwrap(input);
        } catch (err) {
            onInvalid(input, err);
            return null;
        }
    }), filter((msg)=>msg !== null
    ));
}
export function createWrapObserver(observer, wrap) {
    return {
        ...observer,
        next: (msg)=>{
            if (msg != null) {
                observer.next(wrap(msg));
            }
        }
    };
}
export function createWrappedTransport(transport, { wrap , unwrap  }, options = {}) {
    const source = transport.pipe(createUnwrapOperator(unwrap, options));
    const sink = createWrapObserver(transport, wrap);
    return new TransportSubject(source, sink);
}
export function createNamespacedTransport(transport, namespace, options) {
    return createWrappedTransport(transport, createWrapper(namespace), options);
}
